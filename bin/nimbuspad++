#!/usr/bin/env node
// nimbuspad-plus-plus/bin/nimbuspad++

const express = require('express');
const app = express();
const path = require('path');
const fs = require('fs');
const WebSocket = require('ws');
const chokidar = require('chokidar');
const { startVimServer } = require('../src/backend/vim-server');
const { loadMarkdownFiles } = require('../src/utils/file-loader');

app.use(express.static(path.join(__dirname, '../src/ui')));
app.use(express.json());

// Set up WebSocket server for file system events
const wss = new WebSocket.Server({ port: 3002 });
console.log('File system WebSocket server running on ws://localhost:3002');

wss.on('connection', (ws) => {
    console.log('File system WebSocket client connected');

    ws.on('close', () => {
        console.log('File system WebSocket client disconnected');
    });
});

// Watch the repos directory for changes on the host
const reposDir = path.join(__dirname, '../repos');
if (!fs.existsSync(reposDir)) {
    fs.mkdirSync(reposDir, { recursive: true });
    console.log(`Created repos directory: ${reposDir}`);
}

const watcher = chokidar.watch(reposDir, {
    persistent: true,
    ignoreInitial: false,
    awaitWriteFinish: true,
    ignored: '**/.git/**'
});

watcher
    .on('add', (path) => {
        console.log(`File added: ${path}`);
        broadcastFileChange();
    })
    .on('unlink', (path) => {
        console.log(`File removed: ${path}`);
        broadcastFileChange();
    })
    .on('addDir', (path) => {
        console.log(`Directory added: ${path}`);
        broadcastFileChange();
    })
    .on('unlinkDir', (path) => {
        console.log(`Directory removed: ${path}`);
        broadcastFileChange();
    })
    .on('change', (path) => {
        console.log(`File changed: ${path}`);
        broadcastFileChange();
    });

function broadcastFileChange() {
    wss.clients.forEach((client) => {
        if (client.readyState === WebSocket.OPEN) {
            client.send('file-system-changed');
        }
    });
}

app.get('/', (req, res) => {
    res.sendFile(path.join(__dirname, '../src/ui/index.html'));
});

app.get('/load-markdown', (req, res) => {
    const markdownFiles = loadMarkdownFiles();
    res.json(markdownFiles);
});

app.get('/files/:fileName', (req, res) => {
    const fileName = req.params.fileName;
    const filePath = path.join(reposDir, fileName);
    if (fs.existsSync(filePath)) {
        res.sendFile(filePath);
    } else {
        res.status(404).send('File not found');
    }
});

app.get('/list-files', (req, res) => {
    try {
        const files = [];
        const walkDir = (dir, parentPath = '') => {
            const items = fs.readdirSync(dir, { withFileTypes: true });
            for (const item of items) {
                if (item.name.startsWith('.')) continue; // Skip hidden files
                const fullPath = path.join(dir, item.name);
                const relativePath = path.join(parentPath, item.name);
                if (item.isDirectory()) {
                    const dirEntry = {
                        name: item.name,
                        path: relativePath,
                        type: 'directory',
                        children: []
                    };
                    files.push(dirEntry);
                    walkDir(fullPath, relativePath);
                } else {
                    const extension = path.extname(item.name).slice(1) || 'txt';
                    files.push({
                        name: item.name,
                        path: relativePath,
                        type: 'file',
                        extension
                    });
                }
            }
        };

        walkDir(reposDir);

        // Build a tree structure
        const tree = [];
        const map = new Map();
        files.forEach(item => {
            const parts = item.path.split(path.sep);
            let parent = tree;
            let parentPath = '';
            for (let i = 0; i < parts.length - 1; i++) {
                parentPath = path.join(parentPath, parts[i]);
                let dir = map.get(parentPath);
                if (!dir) {
                    dir = files.find(f => f.path === parentPath && f.type === 'directory');
                    if (dir) {
                        parent.push(dir);
                        map.set(parentPath, dir);
                    }
                }
                parent = dir ? dir.children : parent;
            }
            if (item.type === 'file') {
                parent.push(item);
            }
        });

        res.json(tree);
    } catch (error) {
        console.error('Failed to list files:', error);
        res.status(500).send('Failed to list files');
    }
});

app.post('/save-file', (req, res) => {
    const { filePath, content } = req.body;
    const fullPath = path.join(reposDir, filePath);
    try {
        // Check if the path ends with a directory (no extension or known folder name)
        const isDirectory = !path.extname(filePath) || content === '';
        if (isDirectory) {
            fs.mkdirSync(fullPath, { recursive: true });
        } else {
            fs.writeFileSync(fullPath, content, 'utf8');
        }
        res.json({ success: true });
    } catch (error) {
        console.error('Failed to save file or create directory:', error);
        res.status(500).send('Failed to save file or create directory');
    }
});

app.post('/delete-file', (req, res) => {
    const { filePath } = req.body;
    const fullPath = path.join(reposDir, filePath);
    try {
        if (fs.existsSync(fullPath)) {
            if (fs.lstatSync(fullPath).isDirectory()) {
                fs.rmSync(fullPath, { recursive: true, force: true });
            } else {
                fs.unlinkSync(fullPath);
            }
            res.json({ success: true });
        } else {
            res.status(404).send('File or directory not found');
        }
    } catch (error) {
        console.error('Failed to delete file:', error);
        res.status(500).send('Failed to delete file');
    }
});

startVimServer();

app.listen(3000, () => {
    console.log('Nimbuspad++ running at http://localhost:3000');
});
